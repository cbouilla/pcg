import time
import random as r
k = 64
known_up  = 6
known_low  = 11
a = 2549297995355413924 * 2^64 + 4865540595714422341
nbiter = 5
nboutput = 30


polA = [0];
powA = [1];
for i in range (1, nboutput):
    polA.append((polA[i-1] + powA [i-1]) % 2^128)
    powA.append((powA[i-1] * a)% 2^128)


####   MATRIX   ####
def getG(n,mod):
    G = [[1]]
    for i in range(n-1):
        G[0].append(0)
    powA = a % mod
    for i in range(n-1):
        G.append([powA])
        powA = powA * a % mod
        for j in range(n-1):
            if(i == j):
                G[i+1].append(mod)
            else:
                G[i+1].append(0)
    return matrix(G)
        
def getGreduite(n,mod):
    G = getG(n,mod)
    return G.transpose().LLL().transpose()
    
def getInvG(Greduite):
    return Greduite.inverse().n()


Greduite1 = getGreduite(nbiter - 1, 2^k)
invG1 = getInvG(Greduite1)

Greduite2 = getGreduite(nboutput - 1, 2^(2 * k - known_low))
invG2 = getInvG(Greduite2)


def sortiesGenerateur():#OK !
    c = (r.randint(0, 1<<(2 * k)) * 2 + 1) % 1<<(2 * k) #c est impair
    S=[r.randint(0,1<<(k * 2))]
    #c=6364136223846793005 * 2^64 + 1442695040888963407#increment par defaut de pcg (connu)
    #S=[8487854484825256858 + 11929896274893053136 * 2^64]
    for i in range (nboutput-1):
        S.append((S[i] * a + c) % (1<<(2 * k)))
    X=[]
    for i in range (nboutput):
        x=(S[i] % (1<<k))^^(S[i]>>k)
        rot = S[i] >> (2 * k - known_up)
        X.append((x >> rot) | ((x << (k - rot)) % (1 << k)))
    return X,S,c

## Unrotate
def rotateX(X, rot):#OK !
    rX = [];
    for i in range(nbiter):
        rX.append(((X[i] // 2**rot[i]) + ((X[i] * 2**(k - rot[i])) % 2**(k))))
    return rX

def unrotateX(X, rot):#OK !
    rot2 = []
    for i in range(nbiter):
        rot2.append((k - rot[i]) % k)
    return rotateX(X, rot2)

def unrotate1(Xi):#OK !
    return (Xi >> (k - 1)) | ((Xi << 1) % 2**k)
    
###### Sous-fonctions de FindDS######
def getY(W0, WC, rot, uX):#OK !
    Y = [(((powA[i] * W0 + polA[i] * WC) % 2**known_low) ^^ (uX[i] % 2**known_low)) * 2**known_up + (rot[i] ^^ (uX[i] // 2**(k - known_up))) for i in range(nbiter)]
    return Y

def getYprim(Y, WC, W0): #OK ! avec erreurs de retenues ~64bits (polC polW)
    Yprim=[(Y[i] - (polA[i] * WC + powA[i]*W0) // 2**(k - known_up)) % 2**(known_up + known_low) for i in range(nbiter)]
    return Yprim

def getDY(Y, WC, W0): #OK ! avec erreurs de retenues ~64bits (polC polW)
    Yprim = getYprim(Y, WC, W0)
    DY=[(Yprim[i+1] - Yprim[i]) % 2**(known_up + known_low) for i in range(nbiter-1)]
    return DY

######FINDDS######
def FindDS64(uX, rot, W0,WC, invG, Greduite): #rajouter rot dans la version non test ? #OK! ~64bits
    #polW = getPolW(W0)
    Y = getY(W0, WC, rot, uX)
    DY = getDY(Y, WC, W0) #OK avec erreurs de retenues!
    tmp = vector([y * 1<<(k - known_up - known_low) for y in DY])#on rajoute les zéros, recentrage impossible à cause des erreurs de retenues
    u = invG * tmp
    tmp = vector([round(u_) for u_ in u])
    DS64 = Greduite * tmp
    return DS64, Y[0]

######FINDROTI######
#DS64ij = ((polA[j] - polA[i])*DSmod0) % 2**k

def FindRoti(DS640, X, i, Y0, W0,WC):#OK !
    DS640i = (polA[i] * DS640) % (1<<k)
    DSmod0i = ((DS640i << known_low) + W0 * powA[i] + WC * polA[i] - WC - W0) % (1<<(k +known_low))
    # Yi = vraiYi ou vraiYi - 1 à cause de la retenue
    Yi1 = (Y0 + (DSmod0i >> (k - known_up))) % (1 << (known_low + known_up))#avec ou sans retenue
    Yi2 = Yi1 + 1
    Wi = (W0 * powA[i] + WC * polA[i]) % (1 << known_low)
    roti = []
    for j in range(k):
        test1 = (((X ^^ (Yi1 >> known_up)) % (1 << known_low)) == Wi) and ((j ^^ (X >> (k - known_up))) == Yi1 % (1 << known_up))
        test2 = (((X ^^ (Yi2 >> known_up)) % (1 << known_low)) == Wi) and ((j ^^ (X >> (k - known_up))) == Yi2 % (1 << known_up))
        if (test1 or test2) :
            roti.append(j)
        X = unrotate1(X)
    return roti

def FindRot(DS640,X, Y0, W0, WC): #OK !
    tabrot =[]
    for i in range(nboutput):
        tabrot.append(FindRoti(DS640, X[i], i, Y0, W0,WC))
        if(len(tabrot[i]) == 0):
            return []
    return tabrot

def findDS(rot, Greduite, invG): #OK!
    rotprim = []
    for i in range(nboutput):
        rotprim.append((rot[i] - ((powA[i] * W0 + polA[i] * WC) >> (2 * k - known_up))) % (1<<known_up))
    tmp = vector([(rotprim[i+1] - rotprim[i]) << (2 * k - known_up - known_low) for i in range(nboutput - 1)])
    u = invG * tmp
    tmp = vector([round(u_) for u_ in u])
    return Greduite * tmp


def reclistDS(rot, tabrot, Greduite, invG, i):
    if(i == nboutput - 1):
        DS.append(findDS(rot, Greduite, invG))
    for r in tabrot[i]:
        rot[i] = r
        reclistDS(rot, tabrot, Greduite, invG, i+1)


######## ATTENTION CHANGEMENT DE KNOWN_UP DANS LA DEUXIEME PARTIE A RAJOUTER (POUR LE MOMENT 4% DE REUSSITE)
cpt = 0
cptcaca = 0
n = 100

#X, S,c = sortiesGenerateur()
for blabla in range(n):
    X, S,c = sortiesGenerateur()
    '''S=[220067743408853083834432663492647924634, 112503624697201186132469432313340913105, 33070803253007555749993969362658379940, 35318588621369721769182944551411264899, 54991440612027928576873122139768989598, 47538704919747031563607958508390548197, 91156825524452312269810980025165534984, 190824859903544703899471694992400459383, 38874876137985470619763820511870859618, 64791713507446872465937656292282148025, 294090808745917593199968036533303913772, 315273188514388247052667989579897108011, 146787731095195396413033318376746527974, 164532907873775087130926638971532123981, 173700024418981159727549716057111293712, 23840220537461389100772757981679112351, 46659078186011266165472604466461050410, 313115986957003247559634900410071778977, 227881076862105013576926553620126892212, 70006717902022074106179881199979768275, 289258840690156709447527284175095859502, 56879124262013452953008030880000519861, 316795414608248439673818158092187600408, 59351450445612133872438406299462153671, 186880662189473910477044351264016775666, 277302539518883431731773036020970072969, 82600957186847994668020678283213628220, 151784061338883303035759958597934311547, 206823526372995454747724627405580295286, 28223378172317009660412702788180365597, 12739604823225005124700000810730175520, 16831678967949771189519624510262146543, 271393882131248243466756700825368622266, 68326809168772142356935776901049660273, 309598890522762081774973503767990138052, 209697506431394647557286116117164151331, 105155195295356684194249578230279063230, 221667337660693641165849231927196329605, 233097928176036716819591567459546476840, 272924052702129294765082210153888592151, 91129619453905078559147110509515658882, 63377152918107694906757553304785108569, 294054731393013789972178074795267020108, 253719199431407855909971754107928086219, 59661279118893870487270161964263430, 178396699745197382647769246191192755949, 201745583743782479815214201123581723952, 74892753420231538901722059163882030911, 177955269268871404901708611564527746890, 207665034063131991058504413035301530689, 47117448182691552899761748985415214292, 251926336138690226422699058879135819379, 21920620081427058626566501047880998990, 40948628947981751362611318648522238549, 32116981397549781675773852884272601144, 106288622746785276824399697227695888487, 201073164687507533771413717104135802642, 58961305818240342487781420609098046761, 187035094740902698165439775091290735452, 69422795159989247128671625798743347483, 276959103400102038626544844533336428438, 317123296078865307906856881906558802109, 118316234464440768984876141167085046336, 126193093290319439721049830417807705231, 34684565338716933495113128325484258778, 326378529669664343157243240643812339985, 162505873010365714377435760638464233700, 307535243887430424915177821865908709059, 78767001966858986938796323773249115614, 21736014639309382806788004864916978213, 8142198067967511710430496940691127112, 136188421447787428082529779636748217271, 13179930448133522724352488728920384418, 160094123823456764963244619365507303417, 53060966375170460616907241456842009964, 170180072120591957689091167459317761899, 65026522976846060429187948316255523622, 83566908335272890981149727502246489741, 270069377698424539894181982339105131344, 193955648050196766089274953448106290655, 32072259075417170632365625341048776810, 205437048412619765117504993218429125089, 243657878380664846762561218425381009652, 314216884007772061687507879854358549267, 21547734106510126849007993088959326062, 230253912715678204184254042244291876341, 157944739117106803635148773159220517464, 315798993574797912333738059736406600455, 45457985452003221673136408084188386354, 59295338576499191094609957907096420041, 128792130176093318697121508601986126716, 296075200772520420340407948443437853115, 112774076083656296079640508595728986806, 95344702128222893177698901566092775517, 327779169479173880722002966336532367456, 269142690424119837588986706253897581359, 180383975778043342747205834782296983290, 82585949069028235074631213165627170481, 31789759884880583406898243922254535940, 138763445006281736497419485367578766179]

    X = [17099247870330544821, 16525103287338961485, 11099656327266378479, 12055115514965039945, 17887463174005398724, 4611123349176750712, 2075105015530151500, 15239333725326666040, 14165384593400087487, 12519617651531483088, 1780396078768754951, 12699182327927150888, 9628453482698168762, 11813763596395810233, 14881824412991243135, 1682573487323464792, 4384076074220673263, 4923528015372149758, 14282120475191192947, 5407260697446029608, 17051141290474895802, 10519950859929026191, 481368816847871653, 3419869433593986181, 12983290356420683108, 4479923122072191002, 7675952009716311104, 14768314493459496986, 16472672032264156961, 11818772373653359090, 7074120885317410807, 11785158919831506410, 14632691056944267677, 8967982178209062503, 173462718409918877, 15363366419280554619, 14158293927737683038, 2267312972508208072, 12156733958553475580, 11993627971977223404, 16865450475530744192, 9548502980228519440, 14635231067447576866, 1166987275388077361, 14911640411815652225, 1518717880322558154, 1595208010432098988, 17479810013643169011, 16996158924197106291, 15193903901533608407, 843739323743355506, 4264607173903082746, 15534134269290595982, 14866162827784656523, 9883531286508197585, 4866196585758766091, 11452062470478584507, 13299462915787461477, 10454630191204377309, 11632893096100269780, 18305520658513546500, 10648312647800178847, 12835483404871454700, 2851658131835677583, 8216375208867992861, 3813369708647954239, 7877667273655419317, 13072779077845899809, 10962300773519409894, 9388710522349168531, 3050768160949405003, 2534657346251670163, 8180956873183289402, 3766969403493682255, 2732179285267643195, 10312233510784761965, 16920954203147627681, 2312806156915377015, 6079353777730460085, 17635002723201099721, 1114597417050190918, 2926054708721230420, 109602765696320229, 14465421040439468496, 142973387807330164, 5723286195345337151, 16787351955748614244, 16673086541245644531, 8321418753268142321, 7132851848164282239, 12949467371250136223, 218193002640928139, 15065709450458240240, 16702592102178704950, 8383758642546182535, 5402230448090676989, 2020867650377135263, 7710107756126330364, 3209169197681352040, 3131521885099742207]

    c = 117397592171526113268558934119004209487'''

    W0 = S[0] % (1 << known_low)
    WC = c % (1 << known_low)
    rot =[]
    for i in range(nboutput):
        rot.append(S[i] >> (2 * k - known_up))

    uX = unrotateX(X,rot)    
    DS64, Y0 = FindDS64(uX, rot, W0,WC, invG1, Greduite1)#OK!
    tabrot = FindRot(DS64[0],X, Y0, W0, WC)#a l'air OK!
    if(len(tabrot) == 0):
        cptcaca += 1

    DS = findDS(rot, Greduite2, invG2)

    Sprim = [(S[i] - polA[i] * (c % 1<<known_low) - powA[i] * (S[0] % 2^known_low)) % 2^128 for i in range(nboutput)]
    if(DS[0] == ((Sprim[1] - Sprim[0]) >> known_low)):
        cpt += 1
    #print(DS[0])
    #print(12615681514276467327 * 2^64 + 8299778918817149495)
print(n)
print(cpt)
print(cptcaca)
